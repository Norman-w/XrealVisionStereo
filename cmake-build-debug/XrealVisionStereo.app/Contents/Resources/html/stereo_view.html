<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Manual Stereo View</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        /* Styles for debug overlays */
        .debug-overlay {
            position: absolute;
            top: 0;
            height: 100vh; /* Full height */
            width: 50vw; /* Half width */
            border: 2px solid yellow;
            box-sizing: border-box; /* Include border in width/height */
            pointer-events: none; /* Allow clicks to pass through */
            color: yellow;
            font-size: 24px;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align text to top */
            padding-top: 20px;
        }
        #left-eye-overlay {
            left: 0;
        }
        #right-eye-overlay {
            left: 50vw; /* Start at halfway point */
        }
        /* Styles for C++ Log Overlay */
        #cpp-log-overlay {
            position: fixed; /* Fixed position */
            bottom: 10px;
            left: 10px;
            width: calc(100vw - 20px); /* Full width minus padding */
            height: 150px; /* Fixed height */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
            border: 1px solid #555;
            color: #0f0; /* Green text */
            font-family: monospace;
            font-size: 12px;
            overflow-y: scroll; /* Enable vertical scrolling */
            padding: 5px;
            box-sizing: border-box;
            z-index: 100; /* Ensure it's on top */
            pointer-events: none; /* Allow clicks to pass through */
        }
    </style>
</head>
<body>
    <!-- Debug Overlays -->
    <div id="left-eye-overlay" class="debug-overlay">Left Eye</div>
    <div id="right-eye-overlay" class="debug-overlay">Right Eye</div>

    <!-- C++ Log Overlay -->
    <div id="cpp-log-overlay">[C++ Logs]<br></div>

    <!-- Three.js canvas will be appended here by the script -->

    <!-- Use importmap for simpler Three.js loading if desired, or standard script tag -->
    <!-- <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script> -->

    <!-- Or load directly -->
    <script src="three.min.js"></script>
    <!-- <script src="stats.min.js"></script> Remove stats.js -->

    <script>
        console.log("Script block start");

        let scene, camera, renderer, cube;
        let leftCamera, rightCamera; // Manual cameras
        const eyeSep = 0.06;         // Eye separation distance
        // let stats; // Remove stats variable

        // --- Variables for 3D FPS Counter ---
        let fpsTextSprite;
        let fpsCanvas, fpsContext, fpsTexture;
        let lastFPSTime = performance.now();
        let frameCount = 0;
        let currentFPS = 0;
        // --- End FPS Counter Variables ---

        // --- Uniforms for Shaders (Define globally or ensure accessible in animate) ---
        const uniforms = {
            time: { value: 0.0 }
        };

        // --- Vertex Shader (Define a basic one here, or load it too if needed) ---
        const vertexShaderSource = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        // --- End Shader Setup ---

        // --- Shader Definitions ---

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fireShader1 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;

            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            float noise(vec2 co) {
                vec2 i = floor(co); vec2 f = fract(co);
                float a = rand(i); float b = rand(i + vec2(1.0, 0.0));
                float c = rand(i + vec2(0.0, 1.0)); float d = rand(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            void main() {
                vec2 uv = vUv; float t = time * 0.5; uv.y += t;
                float n = noise(uv * 4.0);
                float flameShape = smoothstep(0.1, 0.8, 1.0 - vUv.y); n *= flameShape;
                vec3 black = vec3(0.0); vec3 red = vec3(1.0, 0.1, 0.0);
                vec3 orange = vec3(1.0, 0.5, 0.0); vec3 yellow = vec3(1.0, 1.0, 0.2);
                vec3 color = black;
                color = mix(color, red, smoothstep(0.0, 0.3, n));
                color = mix(color, orange, smoothstep(0.3, 0.6, n));
                color = mix(color, yellow, smoothstep(0.6, 0.8, n));
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const fireShader2 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;

            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }
            float noise (vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f*f*(3.0-2.0*f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm (vec2 st) {
                float value = 0.0; float amplitude = .5;
                for (int i = 0; i < 5; i++) {
                    value += amplitude * noise(st); st *= 2.; amplitude *= .5;
                } return value;
            }
            void main() {
                vec2 uv = vUv; float t = time * 0.8;
                vec2 motion_uv = vec2(uv.x, uv.y + t);
                float n1 = fbm(motion_uv * 3.0); float n2 = fbm(motion_uv * 8.0 + n1 * 0.5);
                float combined_noise = (n1 + n2 * 0.5) / 1.5;
                float flame_intensity = pow(1.0 - vUv.y, 1.5); combined_noise *= flame_intensity;
                vec3 color = vec3(0.0);
                color = mix(color, vec3(0.8, 0.0, 0.0), smoothstep(0.0, 0.25, combined_noise));
                color = mix(color, vec3(1.0, 0.4, 0.0), smoothstep(0.25, 0.5, combined_noise));
                color = mix(color, vec3(1.0, 0.9, 0.3), smoothstep(0.5, 0.75, combined_noise));
                color = mix(color, vec3(1.0, 1.0, 0.8), smoothstep(0.75, 0.9, combined_noise));
                float flicker = pow(noise(vec2(uv.x * 10.0, t * 5.0)), 10.0);
                color += vec3(flicker * 0.2, flicker * 0.1, 0.0);
                gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
            }
        `;

        const fireShader3 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;

            float noise(vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453); }
            void main() {
                vec2 uv = vUv; float t = time * 0.6;
                float distortion = noise(uv * 5.0 + vec2(0.0, -t * 1.5)) * 0.1;
                uv.x += (distortion - 0.05) * pow(1.0 - uv.y, 2.0);
                uv.y += t * 0.5 + distortion * 0.1;
                float n = noise(uv * vec2(3.0, 6.0));
                float intensity = pow(smoothstep(0.0, 0.9, 1.0 - vUv.y), 1.2); n *= intensity;
                vec3 fireColor = mix(vec3(1.0, 0.2, 0.0), vec3(1.0, 0.8, 0.0), smoothstep(0.3, 0.7, n));
                vec3 finalColor = mix(vec3(0.1, 0.0, 0.0), fireColor, smoothstep(0.0, 0.3, n));
                float sparkNoise = noise(vUv * 40.0 + vec2(0.0, -t * 4.0));
                if (sparkNoise > 0.98 && intensity > 0.1) { finalColor = vec3(1.0, 1.0, 0.5); }
                gl_FragColor = vec4(finalColor, smoothstep(0.01, 0.2, n));
            }
        `;

        // --- Fragment Shaders (Water) ---
        const waterShader1 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;
            void main() {
                vec2 uv = vUv; float t = time * 1.5;
                float displacement = sin(uv.x * 20.0 + t) * 0.01 + cos(uv.y * 15.0 - t * 0.8) * 0.01;
                vec2 distortedUv = uv + vec2(displacement);
                vec3 waterColor = vec3(0.1, 0.4, 0.7);
                float highlight = smoothstep(-0.015, 0.015, displacement);
                vec3 color = mix(waterColor * 0.8, vec3(1.0), highlight * 0.5);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const waterShader2 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;
            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            float noise(vec2 co) {
                vec2 i = floor(co); vec2 f = fract(co); float a = rand(i); float b = rand(i + vec2(1.0, 0.0));
                float c = rand(i + vec2(0.0, 1.0)); float d = rand(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float wave(vec2 pos, float freq, float speed, float amplitude) { return sin(pos.x * freq + time * speed) * amplitude; }
            void main() {
                vec2 uv = vUv; float t = time;
                float displacement = 0.0;
                displacement += wave(uv, 15.0, 1.0, 0.01);
                displacement += wave(uv.yx + vec2(0.3, 0.1), 20.0, 0.7, 0.012);
                displacement += wave(uv + vec2(0.1, 0.4), 12.0, 1.3, 0.008);
                displacement += (noise(uv * 10.0 + t * 0.2) - 0.5) * 0.01;
                vec2 distortedUv = uv + vec2(displacement);
                vec3 waterColor = vec3(0.05, 0.3, 0.6);
                float caustic = pow(abs(0.5 - fract(displacement * 10.0)), 20.0);
                caustic *= smoothstep(0.0, 0.01, abs(displacement));
                vec3 color = waterColor + vec3(0.8, 0.9, 1.0) * caustic * 0.8;
                gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
            }
        `;

        const waterShader3 = `
            precision mediump float;
            varying vec2 vUv;
            uniform float time;
            vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
            float snoise(vec2 v) {
              const vec4 C = vec4(0.2113248654, 0.3660254037,-0.5773502691, 0.0243902439);
              vec2 i = floor(v + dot(v, C.yy)), x0 = v - i + dot(i, C.xx);
              vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0);
              vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0));
              vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
              m = m*m; m = m*m; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5); vec3 a0 = x - ox;
              m *= 1.792842914 - 0.85373472 * ( a0*a0 + h*h ); vec3 g;
              g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
            }
            void main() {
                vec2 uv = vUv; float t = time * 0.1;
                float displacement = snoise(uv * 5.0 + t) * 0.005;
                displacement += snoise(uv * 15.0 - t * 0.5) * 0.003;
                vec2 distortedUv = uv + vec2(displacement);
                vec3 baseColor = vec3(0.0, 0.15, 0.3);
                vec3 normal = normalize(vec3(displacement * 10.0, displacement * 10.0, 1.0));
                vec3 viewDir = vec3(0.0, 0.0, 1.0);
                float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, viewDir), 5.0);
                vec3 skyColor = vec3(0.4, 0.6, 0.9);
                vec3 color = mix(baseColor, skyColor, fresnel);
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        // --- End Shader Definitions ---

        // --- Function to Append Logs to UI ---
        const logContainer = document.getElementById('cpp-log-overlay');
        function appendLog(message) {
            if (logContainer) {
                const logEntry = document.createElement('span'); // Use span or div
                logEntry.textContent = message;
                logContainer.appendChild(logEntry);
                logContainer.appendChild(document.createElement('br')); // Add newline
                // Auto-scroll to bottom
                logContainer.scrollTop = logContainer.scrollHeight;
            }
             // Also log to browser console for redundancy
            console.log("[C++ LOG]:", message);
        }
        console.log("appendLog function defined");
        // --- End Log Function ---

        async function init() {
            console.log("init() called - starting async shader loading");

            // --- Load Shaders Asynchronously --- 
            const shaderFiles = [
                // Order matters for material assignment (Right, Left, Top, Bottom, Front, Back)
                'wxfs://glsl/fire_simple.glsl',    // Right (+X)
                'wxfs://glsl/fire_detailed.glsl',  // Left (-X)
                'wxfs://glsl/fire_stylized.glsl',  // Top (+Y)
                'wxfs://glsl/water_simple.glsl',   // Bottom (-Y)
                'wxfs://glsl/water_complex.glsl',  // Front (+Z)
                'wxfs://glsl/water_calm.glsl'      // Back (-Z)
            ];

            let fragmentShaders = [];
            try {
                console.log("Fetching fragment shaders using wxfs:// scheme...");
                const responses = await Promise.all(shaderFiles.map(url => fetch(url)));
                // Check for errors
                for (const response of responses) {
                    if (!response.ok) {
                        throw new Error(`Failed to load shader: ${response.url} (${response.status} ${response.statusText})`);
                    }
                }
                fragmentShaders = await Promise.all(responses.map(res => res.text()));
                console.log("Fragment shaders loaded successfully:", fragmentShaders.length);

            } catch (error) {
                console.error("Error loading shaders:", error);
                // Optionally display an error message to the user on the page
                document.body.innerHTML = `<div style="color:red; padding: 20px;">Error loading shaders. Check console for details. <br/> ${error.message}</div>`;
                return; // Stop initialization if shaders fail
            }
            // --- End Shader Loading ---

            // --- Create Scene FIRST --- 
            scene = new THREE.Scene();
            console.log("Scene created");
            // --- End Scene Creation --- 

            // --- Initialize 3D FPS Counter ---            
            fpsCanvas = document.createElement('canvas');
            fpsCanvas.width = 256;
            fpsCanvas.height = 128;
            fpsContext = fpsCanvas.getContext('2d');
            fpsContext.font = "Bold 40px Arial";
            fpsContext.fillStyle = "rgba(255,255,0,0.95)"; 

            fpsTexture = new THREE.CanvasTexture(fpsCanvas);
            fpsTexture.needsUpdate = true; 

            const spriteMaterial = new THREE.SpriteMaterial({ map: fpsTexture });
            fpsTextSprite = new THREE.Sprite(spriteMaterial);

            const spriteScale = 2;
            fpsTextSprite.scale.set(spriteScale * (fpsCanvas.width / fpsCanvas.height), spriteScale, 1);

            // Adjust position to be more central
            // fpsTextSprite.position.set(-4, 2.5, 0);
            fpsTextSprite.position.set(-2, 1.5, 0); // <-- Move closer to center

            // Add to the *already created* scene 
            scene.add(fpsTextSprite); 
            console.log("3D FPS Counter Sprite added");
            // --- End 3D FPS Counter Init ---

            console.log("Creating main camera...");
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 0, 3.5); // <-- Move camera closer
            camera.updateMatrixWorld();
            console.log("Main camera created");

            // Manual Left Eye Camera
            console.log("Creating left camera...");
            // Start with same params as main camera, aspect will be updated in render loop
            leftCamera = new THREE.PerspectiveCamera(camera.fov, aspect / 2, camera.near, camera.far);
            scene.add(leftCamera); // Add cameras to scene to help with matrix calcs? Maybe not needed.
            console.log("Left camera created");

            // Manual Right Eye Camera
            console.log("Creating right camera...");
            rightCamera = new THREE.PerspectiveCamera(camera.fov, aspect / 2, camera.near, camera.far);
            scene.add(rightCamera);
            console.log("Right camera created");

            // Renderer
            console.log("Creating renderer...");
            renderer = new THREE.WebGLRenderer(/*{ antialias: true }*/);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000); // <-- Black background
            renderer.setScissorTest(true);
            document.body.appendChild(renderer.domElement);
            console.log("Renderer created and added to body");

            // Geometry
            console.log("Creating geometry...");
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            // Remove vertex color/normal setup if shaders don't need it
            // geometry.computeVertexNormals(); 
            // --- Remove Vertex Colors Setup --- 
            // const colors = [];
            // const color = new THREE.Color();
            // const facesColors = ...;
            // const positionAttribute = ...;
            // const colorAttribute = ...;
            // for (let i = 0; ...) { ... }
            // geometry.setAttribute('color', colorAttribute);
            // --- End Remove Vertex Colors Setup ---

            // --- Create Shader Materials using loaded shaders --- 
            console.log("Creating shader materials from loaded files...");
            const shaderMaterials = fragmentShaders.map(fsSource => {
                return new THREE.ShaderMaterial({
                    uniforms: uniforms,              // Use the shared uniforms object
                    vertexShader: vertexShaderSource, // Use the basic vertex shader defined earlier
                    fragmentShader: fsSource          // Use the loaded fragment shader source
                });
            });
            console.log(`Created ${shaderMaterials.length} shader materials`);

            // --- Create Mesh with Shader Materials ---
            // const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide }); // <-- REMOVE OLD MATERIAL
            cube = new THREE.Mesh(geometry, shaderMaterials); // Apply the array of materials
            scene.add(cube);
            console.log("Cube mesh created with loaded shader materials and added to scene");

            // --- Add Grid Helper --- 
            const gridSize = 100; // The overall size of the grid plane
            const gridDivisions = 100; // How many lines in the grid
            const gridColor = 0x888888; // Color for the grid lines
            const centerLineColor = 0xcccccc; // Color for the center lines (X and Z axes)

            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, centerLineColor, gridColor);
            gridHelper.position.y = -1.5; // Position it slightly below the cube's potential lowest point
            scene.add(gridHelper);
            console.log("GridHelper added to scene");
            // --- End Grid Helper --- 

            // Lighting (kept for potential future use)
            console.log("Adding lights...");
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            console.log("Lights added");

            console.log("Adding resize listener...");
            window.addEventListener('resize', onWindowResize, false);
            console.log("Resize listener added");

            console.log("Calling animate()...");
            animate();
            console.log("init() finished");
        }

        function onWindowResize() {
             console.log("onWindowResize() called");
             const width = window.innerWidth;
             const height = window.innerHeight;

             // Update main camera aspect for reference if needed
             camera.aspect = width / height;
             camera.updateProjectionMatrix(); // Update main camera projection

             // Update renderer size
             renderer.setSize(width, height);

             // Aspect for eye cameras will be updated in render loop
        }

        function animate() {
            // stats.begin(); // Remove stats.begin()

            requestAnimationFrame(animate);

            const now = performance.now();
            frameCount++;

            // --- Update FPS Counter (every second) ---
            if (now >= lastFPSTime + 1000) {
                currentFPS = frameCount;
                frameCount = 0;
                lastFPSTime = now;

                // Update canvas texture
                fpsContext.clearRect(0, 0, fpsCanvas.width, fpsCanvas.height);
                // Draw background (optional)
                // fpsContext.fillStyle = "rgba(0,0,0,0.5)";
                // fpsContext.fillRect(0, 0, fpsCanvas.width, fpsCanvas.height);
                fpsContext.fillStyle = "rgba(255,255,0,0.95)"; // Set text color again
                fpsContext.fillText(`FPS: ${currentFPS}`, 10, 50); // Draw text (adjust x,y)
                fpsTexture.needsUpdate = true; // Signal texture update
            }
            // --- End FPS Update ---

            const timeValue = performance.now() * 0.001; // Use performance.now for smooth time

            // --- Update Shader Uniforms --- 
            uniforms.time.value = timeValue; // Update the shared time uniform
            // --- End Update Shader Uniforms ---

            // --- Restore Self-Rotation ---
            cube.rotation.x += 0.003;
            cube.rotation.y += 0.003;

            // --- Z-axis Oscillation ---
            const zAmplitude = 2.0;
            const zFrequency = 0.5; // Slow down oscillation for better shader viewing
            const centerZ = 0.0;
            cube.position.z = centerZ + zAmplitude * Math.sin(zFrequency * timeValue);

            // --- Add Orbital Motion (XY Plane) ---
            const orbitRadius = 2.5;
            const orbitSpeed = 0.3; // Slow down orbit
            cube.position.x = orbitRadius * Math.cos(orbitSpeed * timeValue);
            cube.position.y = orbitRadius * Math.sin(orbitSpeed * timeValue);

            renderStereo();

            // stats.end(); // Remove stats.end()
        }

        function renderStereo() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const halfWidth = width / 2;

            // --- Update Eye Camera Properties ---
            // Update aspect ratio for each eye
            leftCamera.aspect = halfWidth / height;
            rightCamera.aspect = halfWidth / height;

            // Copy main camera settings (orientation, fov etc.)
            leftCamera.fov = camera.fov;
            rightCamera.fov = camera.fov;
            leftCamera.near = camera.near;
            rightCamera.near = camera.near;
            leftCamera.far = camera.far;
            rightCamera.far = camera.far;

            // Apply main camera world matrix
            leftCamera.matrixWorld.copy(camera.matrixWorld);
            rightCamera.matrixWorld.copy(camera.matrixWorld);

            // Apply eye separation offset
            leftCamera.translateX(-eyeSep / 2);
            rightCamera.translateX(eyeSep / 2);

            // Update projection matrices AFTER adjusting position/aspect
            leftCamera.updateProjectionMatrix();
            rightCamera.updateProjectionMatrix();
            // --- End Eye Camera Update ---

            // Render Left Eye
            renderer.setViewport(0, 0, halfWidth, height);
            renderer.setScissor(0, 0, halfWidth, height);
            renderer.render(scene, leftCamera);

            // Render Right Eye
            renderer.setViewport(halfWidth, 0, halfWidth, height);
            renderer.setScissor(halfWidth, 0, halfWidth, height);
            renderer.render(scene, rightCamera);
        }

        // Ensure Three.js is loaded before initializing
        // Use window.onload or defer script loading
        console.log("Setting window.onload = init");
        window.onload = init;
        console.log("window.onload set");

    </script>
</body>
</html> 