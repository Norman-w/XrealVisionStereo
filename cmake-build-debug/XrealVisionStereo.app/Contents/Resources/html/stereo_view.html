<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Manual Stereo View</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        /* Styles for debug overlays */
        .debug-overlay {
            position: absolute;
            top: 0;
            height: 100vh; /* Full height */
            width: 50vw; /* Half width */
            border: 2px solid yellow;
            box-sizing: border-box; /* Include border in width/height */
            pointer-events: none; /* Allow clicks to pass through */
            color: yellow;
            font-size: 24px;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align text to top */
            padding-top: 20px;
        }
        #left-eye-overlay {
            left: 0;
        }
        #right-eye-overlay {
            left: 50vw; /* Start at halfway point */
        }
    </style>
</head>
<body>
    <!-- Debug Overlays -->
    <div id="left-eye-overlay" class="debug-overlay">Left Eye</div>
    <div id="right-eye-overlay" class="debug-overlay">Right Eye</div>

    <!-- Three.js canvas will be appended here by the script -->

    <!-- Use importmap for simpler Three.js loading if desired, or standard script tag -->
    <!-- <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script> -->

    <!-- Or load directly -->
    <script src="three.min.js"></script>
    <!-- <script src="stats.min.js"></script> Remove stats.js -->

    <script>
        console.log("Script block start");

        let scene, camera, renderer, cube;
        let leftCamera, rightCamera; // Manual cameras
        const eyeSep = 0.06;         // Eye separation distance
        // let stats; // Remove stats variable

        // --- Variables for 3D FPS Counter ---
        let fpsTextSprite;
        let fpsCanvas, fpsContext, fpsTexture;
        let lastFPSTime = performance.now();
        let frameCount = 0;
        let currentFPS = 0;
        // --- End FPS Counter Variables ---

        function init() {
            console.log("init() called");

            // --- Create Scene FIRST --- 
            scene = new THREE.Scene();
            console.log("Scene created");
            // --- End Scene Creation --- 

            // --- Initialize 3D FPS Counter ---            
            fpsCanvas = document.createElement('canvas');
            fpsCanvas.width = 256;
            fpsCanvas.height = 128;
            fpsContext = fpsCanvas.getContext('2d');
            fpsContext.font = "Bold 40px Arial";
            fpsContext.fillStyle = "rgba(255,255,0,0.95)"; 

            fpsTexture = new THREE.CanvasTexture(fpsCanvas);
            fpsTexture.needsUpdate = true; 

            const spriteMaterial = new THREE.SpriteMaterial({ map: fpsTexture });
            fpsTextSprite = new THREE.Sprite(spriteMaterial);

            const spriteScale = 2;
            fpsTextSprite.scale.set(spriteScale * (fpsCanvas.width / fpsCanvas.height), spriteScale, 1);

            // Adjust position to be more central
            // fpsTextSprite.position.set(-4, 2.5, 0);
            fpsTextSprite.position.set(-2, 1.5, 0); // <-- Move closer to center

            // Add to the *already created* scene 
            scene.add(fpsTextSprite); 
            console.log("3D FPS Counter Sprite added");
            // --- End 3D FPS Counter Init ---

            console.log("Creating main camera...");
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 0, 3.5); // <-- Move camera closer
            camera.updateMatrixWorld();
            console.log("Main camera created");

            // Manual Left Eye Camera
            console.log("Creating left camera...");
            // Start with same params as main camera, aspect will be updated in render loop
            leftCamera = new THREE.PerspectiveCamera(camera.fov, aspect / 2, camera.near, camera.far);
            scene.add(leftCamera); // Add cameras to scene to help with matrix calcs? Maybe not needed.
            console.log("Left camera created");

            // Manual Right Eye Camera
            console.log("Creating right camera...");
            rightCamera = new THREE.PerspectiveCamera(camera.fov, aspect / 2, camera.near, camera.far);
            scene.add(rightCamera);
            console.log("Right camera created");

            // Renderer
            console.log("Creating renderer...");
            renderer = new THREE.WebGLRenderer(/*{ antialias: true }*/);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000); // <-- Black background
            renderer.setScissorTest(true);
            document.body.appendChild(renderer.domElement);
            console.log("Renderer created and added to body");

            // Geometry
            console.log("Creating geometry...");
            const geometry = new THREE.BoxGeometry(2, 2, 2); // <-- Make cube larger
            geometry.computeVertexNormals(); // Needed if we were using lighting

            // --- Assign Vertex Colors ---
            const colors = [];
            const color = new THREE.Color();
            const facesColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff]; // Red, Green, Blue, Yellow, Magenta, Cyan

            const positionAttribute = geometry.getAttribute('position');
            const colorAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);

             // Each face has 6 vertices (2 triangles)
             // We loop 6 times (for 6 faces)
             for (let i = 0; i < positionAttribute.count; i += 6) {
                 color.setHex(facesColors[i / 6]); // Assign color based on face index
                 // Apply the color to all 6 vertices of the current face
                 for (let j = 0; j < 6; j++) {
                      colorAttribute.setXYZ(i + j, color.r, color.g, color.b);
                 }
             }
            geometry.setAttribute('color', colorAttribute); // Set the color attribute
            // --- End Vertex Colors ---

            const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide }); // <-- Draw both sides
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            console.log("Geometry created and added to scene");

            // --- Add Grid Helper --- 
            const gridSize = 100; // The overall size of the grid plane
            const gridDivisions = 100; // How many lines in the grid
            const gridColor = 0x888888; // Color for the grid lines
            const centerLineColor = 0xcccccc; // Color for the center lines (X and Z axes)

            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, centerLineColor, gridColor);
            gridHelper.position.y = -1.5; // Position it slightly below the cube's potential lowest point
            scene.add(gridHelper);
            console.log("GridHelper added to scene");
            // --- End Grid Helper --- 

            // Lighting (kept for potential future use)
            console.log("Adding lights...");
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            console.log("Lights added");

            console.log("Adding resize listener...");
            window.addEventListener('resize', onWindowResize, false);
            console.log("Resize listener added");

            console.log("Calling animate()...");
            animate();
            console.log("init() finished");
        }

        function onWindowResize() {
             console.log("onWindowResize() called");
             const width = window.innerWidth;
             const height = window.innerHeight;

             // Update main camera aspect for reference if needed
             camera.aspect = width / height;
             camera.updateProjectionMatrix(); // Update main camera projection

             // Update renderer size
             renderer.setSize(width, height);

             // Aspect for eye cameras will be updated in render loop
        }

        function animate() {
            // stats.begin(); // Remove stats.begin()

            requestAnimationFrame(animate);

            const now = performance.now();
            frameCount++;

            // --- Update FPS Counter (every second) ---
            if (now >= lastFPSTime + 1000) {
                currentFPS = frameCount;
                frameCount = 0;
                lastFPSTime = now;

                // Update canvas texture
                fpsContext.clearRect(0, 0, fpsCanvas.width, fpsCanvas.height);
                // Draw background (optional)
                // fpsContext.fillStyle = "rgba(0,0,0,0.5)";
                // fpsContext.fillRect(0, 0, fpsCanvas.width, fpsCanvas.height);
                fpsContext.fillStyle = "rgba(255,255,0,0.95)"; // Set text color again
                fpsContext.fillText(`FPS: ${currentFPS}`, 10, 50); // Draw text (adjust x,y)
                fpsTexture.needsUpdate = true; // Signal texture update
            }
            // --- End FPS Update ---

            const time = Date.now() * 0.001; // Get time in seconds

            // --- Restore Self-Rotation --- 
            cube.rotation.x += 0.003;
            cube.rotation.y += 0.003;

            // --- Z-axis Oscillation --- 
            const zAmplitude = 2.0;
            const zFrequency = 2.5;
            const centerZ = 0.0;
            cube.position.z = centerZ + zAmplitude * Math.sin(zFrequency * time);
            // console.log("Cube Z Position:", cube.position.z.toFixed(2)); // Log Z position

            // --- Add Orbital Motion (XY Plane) ---
            const orbitRadius = 2.5;  // How large is the orbit
            const orbitFrequency = 0.5; // How fast it orbits (lower value is slower)
            cube.position.x = orbitRadius * Math.cos(orbitFrequency * time);
            cube.position.y = orbitRadius * Math.sin(orbitFrequency * time);
            // Log only occasionally
            if (Math.random() < 0.01) { 
                 console.log(`Cube Position: (${cube.position.x.toFixed(2)}, ${cube.position.y.toFixed(2)}, ${cube.position.z.toFixed(2)})`); 
            }
            // --- End Orbital Motion ---

            renderManualStereo();

            // stats.end(); // Remove stats.end()
        }

        function renderManualStereo() {
            renderer.clear();
            const width = window.innerWidth;
            const height = window.innerHeight;
            const halfWidth = width / 2;

            // 1. Update main camera's world matrix (important!)
            camera.updateMatrixWorld(true);

            // 2. Update Left Camera
            leftCamera.near = camera.near;
            leftCamera.far = camera.far;
            leftCamera.fov = camera.fov; // Keep FOV same for simplest approach
            leftCamera.aspect = halfWidth / height; // Aspect ratio for half screen
            leftCamera.position.copy(camera.position);
            leftCamera.position.x -= eyeSep / 2; // Apply offset
            leftCamera.quaternion.copy(camera.quaternion); // Match orientation
            leftCamera.updateProjectionMatrix(); // Update projection based on new aspect/fov

            // 3. Update Right Camera
            rightCamera.near = camera.near;
            rightCamera.far = camera.far;
            rightCamera.fov = camera.fov;
            rightCamera.aspect = halfWidth / height;
            rightCamera.position.copy(camera.position);
            rightCamera.position.x += eyeSep / 2;
            rightCamera.quaternion.copy(camera.quaternion);
            rightCamera.updateProjectionMatrix();

            // --- DEBUG LOGGING ---
            let leftPos = new THREE.Vector3();
            let rightPos = new THREE.Vector3();
            leftCamera.getWorldPosition(leftPos); // Use the eye cameras directly
            rightCamera.getWorldPosition(rightPos);

            if (Math.random() < 0.01) {
                console.log(`--- Frame Debug ---`);
                console.log(`Left Eye Pos : (${leftPos.x.toFixed(2)}, ${leftPos.y.toFixed(2)}, ${leftPos.z.toFixed(2)}) | fov: ${leftCamera.fov.toFixed(1)}, near: ${leftCamera.near.toFixed(1)}, far: ${leftCamera.far.toFixed(1)}, aspect: ${leftCamera.aspect.toFixed(2)}`);
                console.log(`Right Eye Pos: (${rightPos.x.toFixed(2)}, ${rightPos.y.toFixed(2)}, ${rightPos.z.toFixed(2)}) | fov: ${rightCamera.fov.toFixed(1)}, near: ${rightCamera.near.toFixed(1)}, far: ${rightCamera.far.toFixed(1)}, aspect: ${rightCamera.aspect.toFixed(2)}`);
                console.log(`Main Cam Pos : (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}) | fov: ${camera.fov.toFixed(1)}, near: ${camera.near.toFixed(1)}, far: ${camera.far.toFixed(1)}, aspect: ${camera.aspect.toFixed(2)}`);
            }
            // --- END DEBUG LOGGING ---


            // 4. Render Left Eye
            renderer.setScissor(0, 0, halfWidth, height);
            renderer.setViewport(0, 0, halfWidth, height);
            renderer.render(scene, leftCamera); // Use leftCamera

            // 5. Render Right Eye
            renderer.setScissor(halfWidth, 0, halfWidth, height);
            renderer.setViewport(halfWidth, 0, halfWidth, height);
            renderer.render(scene, rightCamera); // Use rightCamera
        }

        // Ensure Three.js is loaded before initializing
        // Use window.onload or defer script loading
        console.log("Setting window.onload = init");
        window.onload = init;
        console.log("window.onload set");

    </script>
</body>
</html> 